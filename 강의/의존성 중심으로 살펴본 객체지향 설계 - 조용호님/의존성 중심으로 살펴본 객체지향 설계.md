
조용호님의 의존성에 관련된 오해를 풀기 특강

# 1. 설계에 대한 이야기
---
### 설계란? 
- 코드 배치
- 머리속에 있는 **알고리즘**과 **데이터**를 어떤 기준에 따라 나누고 연결하는 것
	- 코드를 나누고 그 코드가 런타임에 돌아갈수있도록 의존성을 연결하는 것
- 코드를 짜기 전에 설계를 해야한다는 생각 버리기

### 설계를 할때 결정해야할 것 두가지
- 코드를 나누는 경계 (경계)
- 코드를 연결하는 방향 (의존성)

- 경계와 의존성을 결정하는 기준 -> 요구사항변경

> 설계의 목적 : *수정할 코드를 쉽게 찾고(경계) 코드를 수정할 때 부수효과를 최소화하기 위해(의존성)* -> 이것이 객체지향 설계의 최종 목적이다.

- 부수효과란 테스트할 범위, 영향도 전파 등

-  각각의 프로그램 패러다임은 이 두가지(경계와 의존성)를 결정하는 기준이 각기 다른 것.
- 즉 절대적인 룰은 없다. 요구사항은 (무조건)변경되고 어떻게 변경될지에 대한 생각은 사람마다 다르기 때문에
- 이것이 설계가 CaseByCase인 이유. 각자 핵심을 두는 방향이 다르다.

- 그래도 기준은 있다.
	- 경계를 결정하는 기준 : 변경되는 이유와 시점이 같은 코드끼리 분리
	- 의존성 방향을 결정하는 기준 : 변경 시의 상대적인 안전성. 
        - 상대적으로 불안하게 변경할 코드 --(의존성)--> 상대적을 안정적으로 변경하고 싶은 코드


# 2. 전통적인 절차적인 설계 방법
---
### 예제 프로젝트 (영화) 이해하기
- 도메인 개념
	- 영화
	- 상영
	- 할인 정책 - 금액할인, 비율할인 
		- 하나의 영화는 최대 하나의 할인 정책을 설정할 수 있다.
	- 할인 조건 - 순서조건, 기간조건
		- 할인 정책은 1개 이상의 할인 조건을 갖는다. 조건 중 하나면 만족하면 할인
	- 예매

### 절차적인 방식으로 설계된 코드

데이터(객체) : 무엇을 저장할 것인가
프로세스(알고리즘) : 어떻게 처리할 것인가

- 절차지향 방식의 설계 스타일
	- 데이터 구현 
		- 필드는 클래스 내부에 캡슐화. 어떤 상황에서도 제한없이 접근 가능하게 getter/setter 추가
		- 각 데이터 마다 영속성 저장소와 상호 작용을 담당하는 DAO 객체 생성
	- 프로세스 정의 
		- service 클래스 안에 로직을 구현하는 메소드 정의
		- DB 조회부터 비즈니스 로직, 다시 DB 저장까지 하나의 클래스에서 순차적으로 실행된다.
		- 프로세스를 구현한 커다란 service 클래스

-> 데이터와 프로세스가 구분되며 상태를 바꾸는 로직(프로세스)과 대상이되는 데이터가 다른 클래스에 존재한다면 절차적인 방식이다.


- 절차지향 방식 설계의 문제점
	- 데이터 
		- 어떤 상황에서도 제한없이 접근 가능한 getter/setter의 허용 -> 결론적으로 캡술화된게 아니다. 
		- 해당 데이터가 어디서 쓰일지 생각하지 않은 방식이다. 아무나 가져다 쓰고 상태를 바꿔도되~ 상태
		- 이런건 '객체'가 아닌 그냥 단순한 '데이터' 형식
	- 프로세스
		- servie가 db에 접속하는 모든 클래스와 의존성을 가진다.
		- 로직이 길어저 메소드를 쪼갤수는 있지만 한 클래스에서 단순히 메소드를 쪼개는 것은 객체지향적인 방식은 아니다.
		- 클라이언트가 데이터의 타입을 판단한다.
			- 데이터는 타입과 값만 가질뿐 아무것도 안함
			- 데이터의 타입을 체크하는게 클라이언트에 위치한다면 절차적인 방식이다.
			- 께져버린 캡술화
		- 프로세스를 구현한 커다란 클래스 -> 부수효과 증가



# 3. 경계와 의존성
-----

### 의존성
다른 코드가 수정될때 함께 수정될 수 있는 가능성
- *의존성의 바향과 반대로 변경의 영향이 미친다.*
	- A -> B 의존시 B 코드를 변경할때 A 코드도 함께 변경

의존성이란?
- 클래스 안에 포함된 다른 클래스의 텍스트의 의존성
	- B class의 클래스 이름을 변경할때 A class도 변경해줘야 할떄 ㅇ의존성이 있는 것

- 상대적으로 덜 중요한 애가 중요한 애를 의존하도록 해야한다.

### 경계를 결정하는 기준
- 변경되는 이유와 시점이 같은 코드끼리 경계

- 잘못된 경계 (절차적인 설계에서의 경계)
	- 데이터가 변경될 때 데이터를 사용하는 여~러 프로세스는 함께 변경
	- 디비 읽고 수정하고 디비 저장하고 등이 모두 한 경계에 있다.
	- 실행 흐름 안에 메서드의 목적에 따라 분리. 실행 흐름대로 메소드가 읽힌다.
		- 이러면 너무 길어져서 메소드를 쪼갬. 실행 순서대로 메소드 정렬
		- 서로 다른 이유로 변경되는 메소드가 하나의 클래스에 공존한다.

-> 함계 변경되는 프로세스와 데이터가 별도의 분리된 모듈에 구현
-

### 의존성의 방향을 결정하는 기준
- 의존성의 뱡항이 안정적인 애들을 향하게
- 데이터에 의존성을 걸면 파급효과 제어의 어려움. (자주 바뀌는건 데이터?)
	- 데이터가 변경될때 함께 수정될 부분을 예측하고 제어하기 어령움

- 실행 흐름에서 중요한 정책이 덜 중요한 세부사항 의존
	- 큰 플로우는 그대로 두고 세부적인 정책을 변경하는 것이 안정적인 방식이다. 



## 해결방법
-> 함께 변경되는 프로세스와 데이터를 하나의 클래스 안에 구현
-> 다른 시점에 변경되는 메소드들은 하나의 클래스 안에 공존

- 클래스를 작게 쪼개기. 작은 클래스 지향 (변경지점이 동일한 애들만 모아두기)

-> 프로세스와 데이터를 포함하는 객체가 다른 객체에계 메세지를 통해 통ㅇ신
-> 의존성을 역적시켜 세부 사항 때문에 중요한 정책이 변경되는 방식
	(짜치는 애들이 중요한 애들한ㄴ데 의존성 걸기)


절차적인 설계가 나쁜것은 아니다. 데이터를 객체지향적으로 짜려고할때 어색한 부분이 있다면 절차가 맞다

# 객체지향 설계
하나의 클래스에 전부 구현하는 절차지향과 다르게 ....

데이터와 메서드를 함께 가지는 클래스로 분리

- 책임주도설계 살펴보기
	- 행동을 결정하고 데이터를 뒤로 미룬다. 데이터를 바꿔도 흔들림이 덜 하다
	- 절차적인 방식은 상태를 앞으로 뺀다. 
	- 행위 관점의 설계


행위부터결정(TDD) -> 적합한 객체에게 할당

적합한 객체를 선택하는 것이란.. 정답이 없음.
코드의 상태를 바꿀때 사이드이팩트가 밖으로 안나갔으면 좋겠다.
도메인 개념 중 적절한 정보 전문가에게 할당 (코드를 수정하기 좋은 모델을 선택하는것. 현실세계 모델이랑 일치시킬 순 없다.)

명사형으로 묶는 이유 : 코드찾기가 쉽다 (표현적 차이 줄이기)

그럼 누구한테 할당해야 합리적일까????
- 의존성의 개수 줄이는 방식
- 목적어를 주어로! 파라미터가 주어로? 예매를 상영에 할당ㅇ한다.

세부적인 알고리즘은 나중에 정하고 큰틀을 먼저 정하기
상태를 캡슐화했다 -> 상태를 무시하고 코드짜기

할인 정책을 판단하는 로직은 할인 정책 객체 안에 있어야함. -> 다형성 (할인정책이 어떤 타입인지)


### 의존성 방향
변경 시의 상대적인 안정성

인터페이스를 이용해서 의존성 역전 (다형성)
 - 추상하는 안정적으로 잡아야핟나.
 - 중요한 정책은 고정 
 - 중요한 정책이 인터페이스를 의존하고 구현체도 인터페이스를 위존한다.
 - 구현체가 바껴서 추상체가 변경되었다?? 완전 잘못 짰다~
 - DIP
 - 프레임워크가 일반적으로 이러한 구조이다.
 - 짜치는 애들 (구현체) ㅇ의존성이 중ㅇ요한 로직을 바라본다.
 - 기존 코드를 수정하지 않고 할인 정책과 할인 조건 변경 가능해졌다  두둥


# 요구사항 변경

어떤 설계를 할때는 A라는 변경을 대비해서 설계를 한다. 모든 변경 사항에 대해서 대비할 수는 없음.
요구사항이 바뀌는 건 당연하다. 요구사항이 바뀌는 것을 싫어하면 안됨.

코드는 길어져도 읽기 편하는 짜는게 좋다.

composite 디자인 패턴
Movie는 DiscountPolicy의 개수와 무관ㄴ하게 협력 가능

# 큰 규모에서 의존성 다루기
### 관심사의 분리
- 패키지를 나눌때 변경에 따라 나눠야됟나. 
- 중요한건 도메인 레이어. 의존성을 안으로... 핵사고날 느낌 ㅇ왜냐면 도메인 레이어가 제일 중요하니까!!
- 도메인 로직에는 기술적인 내용이 하나도 없어야한다. 데이터를 조회, 저장을 콜하는 것도 서비스레이어의 역할 
- 트랜잭션 관리도 도메인레이어에 있ㅇ으면 안된ㄴ다. 


- 요청별로 변경의 속도가 다르다면?
	- 레이어로 짜른게 잘못한거다. 레이어를 잘못짠거
	- 요청별로 수직 슬라이스 경계 분리하고 버티컬 별로 의존성을 가진다.
	-> 변경을 기준으로 경계를 분리하기

> 중요한 것은 일관성이 있는 경계와 의존성 (팀이 일관성이 있어야함)
> 그리고 최대한 단순하게 (레이어가 많아지는 것은 안좋다)


### 질문
- 도메인 비즈니스 로직을 넣는다면 JPA와 분리되어야한다고 생각한다..JPA entity는 DB에 너무 의존적인 객체하고 생각함. 연관관계 매핑이라던가..영속성과 관련된 기술적인 요소에 종속
- N+1 문제를 해결하기 위한 대안에 Entity Graph와 Fetch join이 있는데 개발자입장에서는 fetch join이 더 쓰기편해 entity graph를 쓰지 않게 되는것 같습니다. 어떤 케이스에 entity graph 적용하면 좋을까요?



절차지향방식을 고수해야하는 케이스
fetch join 

- 객체를 읽을때 ㅇ어디서 부터 어디까지 읽을 수 있을지 정해줘야한다.
- 일관성 있게 가져올 수 있도록 객체를 설계한다면 


실서비스에서는 어떤 범위의 변경사항이 발생할지 예상하기가 힘든데, 변경사항을 예상해서 적절한 클래스로 쪼개는게 가능할지 의문이 듭니다. 열심히 객체지향으로 설계해놨는데, 변경 요구사항으로 인해 다 뜯어고치는 상황이 생길 수 있는데, 이런 경우는 절차지향 설계가 더 적절할 수도 있나요?
-> 그래도 객체지향.
관계는 고정



# 질문
