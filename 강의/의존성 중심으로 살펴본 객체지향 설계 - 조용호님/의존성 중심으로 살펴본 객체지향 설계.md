
조용호님 
의존성에 관련된 오해를 풀기

# 설계에 대한 이야기

- 설계란? 
	- 코드를 배치하는 방식
	- 코드가 있을때 어떻게 배치할까 고민하는 것이 설계
	- 코드를 짜기 전에 설계를 해야한다는 생각 버리기
	- 코드를 짠다
		- 알고리즘
		- 데이터
	- 코드를 나누고 그 코드가 런타임에 돌아갈수있도록 의존성을 연결하는 것

- 설계를 할 때 결정하는 두가지
	- 경계나누기
	- 의존성 설정하기 (코드 연결하는 방향)
	-> 프로그램 패더라임 마다 이 두가지가 다른 것이다. 
	-> 절대적인 룰이 없음. 요구사항은 변경되고 어떻게 변경될지에 대해서 생각하는 사람 마다 다르기 떄문에
	-> 설계가 case by case 인 이유. 각자 핵심을 다눈 뱡향이 다르다.

- 그래도 기준은 있다. 
	- 변경되는 이유와 시점이 같은 코드들끼리 분리 : 같이 변경되는 애들끼리 경계 묶기
	- 의존성의 방향을 결정하는 기준
		- 변경 시의 상대적인 안정성
		- 의존성방향 : 상대적으로 불안정하게 변경될 코드 -> 상태적으로 안정적으로 변경하고 싶은 코드

- 설계의 목적
	1. 수정할 코드를 쉽게 찾기 위해. -> 경계
	2. 코드를 수정할 때 부수효과를 최소화하기 위해 (테스트할 범위 줄이기. 전파 줄이기) -> 의존성

결국 객체지향의 설계의 최종목적은 위 두 가지이다. 


# 전통적인 절차적인 설계 방법

### 예제 프로젝트 (영화)

1. 요구사항 분석 (도메인 개념)
	- 영화
	- 상영
	- 할인 정책 - 금액할인, 비율할인 
		- 하나의 영화는 최대 하나의 할인 정책을 설정할 수 있다.
	- 할인 조건 - 순서조건, 기간조건
		- 할인 정책은 1개 이상의 할인 조건을 갖는다. 조건 중 하나면 만족하면 할인
	- 예매

### 절차적인 방식으로 설계된 코드
데이터랑 프로세스가 구분된다. 
상태를 바꾸는 로직과 대상이되는 데이터가 다른 클래스에 있다면 절차적인 방식이다.

- 데이터 구현
	- 기본적으로 테이블 당 하나씩 class 만들기 + getter, setter 
		- 결론적으로 캡슐화 안됨. 
		- 이런건 객체가 아니라 그냥 데이터
		- 해당 데이터가 어디서 쓰일지 생각하지 않은 방식이다. 아무나 가져다 쓰고 상태를 바꿔도되~ 상태임

- 프로세스 구현
	- service 클래스에 프로세스를 구현하기 위한 메서드 정의
	- db에 접속하는 class를 모두 가진다.
	- 실행순서대로 알고리즘을 작성한다.
	- 코드가 길어져서 메소드를 자를 순 있다.
	- 클라이언트가 데이터의 타입을 판단한다.
		- 데이터는 타입과 값만 가질뿐 아무것도 안함
		- 데이터의 타입을 체크하는게 클라이언트에 있다면 절차적인 방식이다.
		- 께져버린 캡술화
	- 프로세스를 구현한 커다란 클래스 -> 부수효과의 증가
		- class를 쪼개야한다. (경계)


# 경계와 의존성
### 의존성
다른 코드가 수정될때 함께 수정될 수 있는 가능성
- *의존성의 바향과 반대로 변경의 영향이 미친다.*
	- A -> B 의존시 B 코드를 변경할때 A 코드도 함께 변경

의존성이란?
- 클래스 안에 포함된 다른 클래스의 텍스트의 의존성
	- B class의 클래스 이름을 변경할때 A class도 변경해줘야 할떄 ㅇ의존성이 있는 것

- 상대적으로 덜 중요한 애가 중요한 애를 의존하도록 해야한다.

### 경계를 결정하는 기준
- 변경되는 이유와 시점이 같은 코드끼리 경계

- 잘못된 경계 (절차적인 설계에서의 경계)
	- 데이터가 변경될 때 데이터를 사용하는 여~러 프로세스는 함께 변경
	- 디비 읽고 수정하고 디비 저장하고 등이 모두 한 경계에 있다.
	- 실행 흐름 안에 메서드의 목적에 따라 분리. 실행 흐름대로 메소드가 읽힌다.
		- 이러면 너무 길어져서 메소드를 쪼갬. 실행 순서대로 메소드 정렬
		- 서로 다른 이유로 변경되는 메소드가 하나의 클래스에 공존한다.

-> 함계 변경되는 프로세스와 데이터가 별도의 분리된 모듈에 구현
-

### 의존성의 방향을 결정하는 기준
- 의존성의 뱡항이 안정적인 애들을 향하게
- 데이터에 의존성을 걸면 파급효과 제어의 어려움. (자주 바뀌는건 데이터?)
	- 데이터가 변경될때 함께 수정될 부분을 예측하고 제어하기 어령움

- 실행 흐름에서 중요한 정책이 덜 중요한 세부사항 의존
	- 큰 플로우는 그대로 두고 세부적인 정책을 변경하는 것이 안정적인 방식이다. 



## 해결방법
-> 함께 변경되는 프로세스와 데이터를 하나의 클래스 안에 구현
-> 다른 시점에 변경되는 메소드들은 하나의 클래스 안에 공존

- 클래스를 작게 쪼개기. 작은 클래스 지향 (변경지점이 동일한 애들만 모아두기)

-> 프로세스와 데이터를 포함하는 객체가 다른 객체에계 메세지를 통해 통ㅇ신
-> 의존성을 역적시켜 세부 사항 때문에 중요한 정책이 변경되는 방식
	(짜치는 애들이 중요한 애들한ㄴ데 의존성 걸기)


절차적인 설계가 나쁜것은 아니다. 데이터를 객체지향적으로 짜려고할때 어색한 부분이 있다면 절차가 맞다

# 객체지향 설계
하나의 클래스에 전부 구현하는 절차지향과 다르게 ....

데이터와 메서드를 함께 가지는 클래스로 분리

- 책임주도설계 살펴보기
	- 행동을 결정하고 데이터를 뒤로 미룬다. 데이터를 바꿔도 흔들림이 덜 하다
	- 절차적인 방식은 상태를 앞으로 뺀다. 
	- 행위 관점의 설계


행위부터결정(TDD) -> 적합한 객체에게 할당

적합한 객체를 선택하는 것이란.. 정답이 없음.
코드의 상태를 바꿀때 사이드이팩트가 밖으로 안나갔으면 좋겠다.
도메인 개념 중 적절한 정보 전문가에게 할당 (코드를 수정하기 좋은 모델을 선택하는것. 현실세계 모델이랑 일치시킬 순 없다.)

명사형으로 묶는 이유 : 코드찾기가 쉽다 (표현적 차이 줄이기)

그럼 누구한테 할당해야 합리적일까????
- 의존성의 개수 줄이는 방식
- 목적어를 주어로! 파라미터가 주어로? 예매를 상영에 할당ㅇ한다.

세부적인 알고리즘은 나중에 정하고 큰틀을 먼저 정하기
상태를 캡슐화했다 -> 상태를 무시하고 코드짜기

할인 정책을 판단하는 로직은 할인 정책 객체 안에 있어야함. -> 다형성 (할인정책이 어떤 타입인지)


### 의존성 방향
변경 시의 상대적인 안정성

인터페이스를 이용해서 의존성 역전 (다형성)
 - 추상하는 안정적으로 잡아야핟나.
 - 중요한 정책은 고정 
 - 중요한 정책이 인터페이스를 의존하고 구현체도 인터페이스를 위존한다.
 - 구현체가 바껴서 추상체가 변경되었다?? 완전 잘못 짰다~
 - DIP
 - 프레임워크가 일반적으로 이러한 구조이다.
 - 짜치는 애들 (구현체) ㅇ의존성이 중ㅇ요한 로직을 바라본다.
 - 기존 코드를 수정하지 않고 할인 정책과 할인 조건 변경 가능해졌다  두둥


# 요구사항 변경

어떤 설계를 할때는 A라는 변경을 대비해서 설계를 한다. 모든 변경 사항에 대해서 대비할 수는 없음.
요구사항이 바뀌는 건 당연하다. 요구사항이 바뀌는 것을 싫어하면 안됨.

코드는 길어져도 읽기 편하는 짜는게 좋다.

composite 디자인 패턴
Movie는 DiscountPolicy의 개수와 무관ㄴ하게 협력 가능

# 큰 규모에서 의존성 다루기
### 관심사의 분리
- 패키지를 나눌때 변경에 따라 나눠야됟나. 
- 중요한건 도메인 레이어. 의존성을 안으로... 핵사고날 느낌 ㅇ왜냐면 도메인 레이어가 제일 중요하니까!!
- 도메인 로직에는 기술적인 내용이 하나도 없어야한다. 데이터를 조회, 저장을 콜하는 것도 서비스레이어의 역할 
- 트랜잭션 관리도 도메인레이어에 있ㅇ으면 안된ㄴ다. 


- 요청별로 변경의 속도가 다르다면?
	- 레이어로 짜른게 잘못한거다. 레이어를 잘못짠거
	- 요청별로 수직 슬라이스 경계 분리하고 버티컬 별로 의존성을 가진다.
	-> 변경을 기준으로 경계를 분리하기

> 중요한 것은 일관성이 있는 경계와 의존성 (팀이 일관성이 있어야함)
> 그리고 최대한 단순하게 (레이어가 많아지는 것은 안좋다)


### 질문
- 도메인 비즈니스 로직을 넣는다면 JPA와 분리되어야한다고 생각한다..JPA entity는 DB에 너무 의존적인 객체하고 생각함. 연관관계 매핑이라던가..영속성과 관련된 기술적인 요소에 종속
- N+1 문제를 해결하기 위한 대안에 Entity Graph와 Fetch join이 있는데 개발자입장에서는 fetch join이 더 쓰기편해 entity graph를 쓰지 않게 되는것 같습니다. 어떤 케이스에 entity graph 적용하면 좋을까요?



절차지향방식을 고수해야하는 케이스
fetch join 

- 객체를 읽을때 ㅇ어디서 부터 어디까지 읽을 수 있을지 정해줘야한다.
- 일관성 있게 가져올 수 있도록 객체를 설계한다면 


실서비스에서는 어떤 범위의 변경사항이 발생할지 예상하기가 힘든데, 변경사항을 예상해서 적절한 클래스로 쪼개는게 가능할지 의문이 듭니다. 열심히 객체지향으로 설계해놨는데, 변경 요구사항으로 인해 다 뜯어고치는 상황이 생길 수 있는데, 이런 경우는 절차지향 설계가 더 적절할 수도 있나요?
-> 그래도 객체지향.
관계는 고정